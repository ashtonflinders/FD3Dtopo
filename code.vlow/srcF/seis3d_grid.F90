program seis3d_grid

! This program generates grid coordinate
!
! Author: Wei ZHANG     Email: zhangwei.zw@gmail.com
! Copyright (C) 2006 Wei ZHANG

!*****************************************************************************
!
! $Date: 2009-01-07 22:08:34 -0500 (Wed, 07 Jan 2009) $
! $Revision: 496 $
! $LastChangedBy: zhangw $
!
!*****************************************************************************

#include "mod_macdrp.h"

use constants_mod
use string_mod
use para_mod
use math_mod
use mpi_mod
use nfseis_mod
use grid_mod
use io_mod
#ifdef GridMPI
use mpi
#endif

implicit none

!-----------------------------------------------------------------------------

type STRUCT_POINT
     logical :: yes
     character (len=SEIS_STRLEN) :: fnm,filetype
     integer,dimension(SEIS_GEO) :: start,count,stride
end type STRUCT_POINT
type STRUCT_VMAPASCII
     logical :: yes
     character (len=SEIS_STRLEN) :: fnm,filetype
     integer :: ni,nj,nk,ngi,ngj
     real(SP),dimension(:),pointer :: gx,gy
     real(SP),dimension(:),pointer :: x,y
     real(SP),dimension(:,:,:),pointer :: z,zgrid
     integer,dimension(:),pointer :: nspace,indx
     logical,dimension(:),pointer :: equal
end type STRUCT_VMAPASCII
type STRUCT_VMAPNC
     logical :: yes
     character (len=SEIS_STRLEN) :: fnm,filetype
     integer :: ni,nj,nk
     real(SP),dimension(:,:),pointer :: x,y
     real(SP),dimension(:,:,:),pointer :: zgrid
     integer,dimension(:),pointer :: nspace,indx
     logical,dimension(:),pointer :: equal
end type STRUCT_VMAPNC

type (STRUCT_POINT) :: P
type (STRUCT_VMAPASCII) :: VA
type (STRUCT_VMAPNC) :: VN

character (len=SEIS_STRLEN) :: filenm
integer,dimension(SEIS_GEO) :: subs,subc,subt

integer :: n_i,n_j,n_k
#ifdef GridMPI
integer :: ierr
#endif

!-----------------------------------------------------------------------------

#ifdef GridMPI
call MPI_INIT(ierr)
#endif

call get_conf_name(fnm_conf)

call swmpi_init(fnm_conf)
call para_init(fnm_conf)

#ifdef GridMPI
call swmpi_cart_creat
call swmpi_reinit_para
call swmpi_datatype
#else
call swmpi_set_gindx(0,0,0)
#endif

call grid_fnm_init(fnm_conf)
call grid_alloc(iscoord=.true.)

call init_grid(fnm_grid_conf)

!-----------------------------------------------------------------------------

#ifdef GridMPI
   n_i=thisid(1); n_j=thisid(2); n_k=thisid(3)
#else
do n_i=0,dims(1)-1
do n_j=0,dims(2)-1
do n_k=0,dims(3)-1
   write(*,"(i10,2(i2),a,3(i2))") n_i,n_j,n_k, ' of ',dims
   call swmpi_change_fnm(n_i,n_j,n_k)
   call swmpi_set_gindx(n_i,n_j,n_k)
#endif

   if (P%yes) call point_read(P)

   if (VA%yes) call vmapascii_generate(VA)

   if (VN%yes) call vmapnc_generate(VN)

   call coord_extend

#ifdef GridMPI
   if (masternode) write(*,*) "exchange coord..."
   call coord_exchange
#endif

#ifdef GridMPI
   if (masternode)  &
#endif
   print *, '  export coord...'
   filenm=grid_coordfnm_get(n_i,n_j,n_k)
   call coord_skel(filenm)
   subs=(/ nx1,ny1,nz1 /); subc=(/ nx,ny,nz /); subt=(/ 1,1,1 /)
   call nfseis_varput( filenm,'x', x, subs,subc,subt)
   call nfseis_varput( filenm,'y', y, subs,subc,subt)
   call nfseis_varput( filenm,'z', z, subs,subc,subt)

#ifndef GridMPI
end do
end do
end do

    print *, 'exchange coord ...'
    call coord_exchange
#endif

!-----------------------------------------------------------------------------
#ifdef GridMPI
call MPI_BARRIER(SWMPI_COMM,ierr)
if (masternode) then
#endif
print *, 'output topography coordinate ...'
call topo_alloc
n_k=dims(3)-1
do n_i=0,dims(1)-1
do n_j=0,dims(2)-1
   call swmpi_change_fnm(n_i,n_j,n_k)
   call swmpi_set_gindx(n_i,n_j,n_k)
   filenm=grid_coordfnm_get(n_i,n_j,n_k)
   subs=(/ni1,nj1,nk2/)
   subc=(/ni,nj,1/)
   subt=(/ 1,1,1 /)
   call nfseis_varget(filenm,'x',topox(npi1:npi2,npj1:npj2),subs,subc,subt)
   call nfseis_varget(filenm,'y',topoy(npi1:npi2,npj1:npj2),subs,subc,subt)
   call nfseis_varget(filenm,'z',topoz(npi1:npi2,npj1:npj2),subs,subc,subt)
end do
end do

call topo_output(trim(pnm_grid)//'/'//trim(fnm_topo))

#ifdef GridMPI
end if
#endif

!-----------------------------------------------------------------------------
call grid_dealloc

#ifdef GridMPI
call MPI_BARRIER(SWMPI_COMM,ierr)
call MPI_FINALIZE(ierr)
#endif

!-----------------------------------------------------------------------------
contains
!-----------------------------------------------------------------------------

subroutine coord_skel(filenm)
  character (len=*),intent(in) :: filenm
  integer,dimension(SEIS_GEO) ::subs,subc,subt
  call nfseis_grid3d_skel(filenm,nx,ny,nz,"Grid coord generated by seis3d_grid" )
     subs=(/ nx1,ny1,nz1 /); subc=(/ nx,ny,nz /); subt=(/ 1,1,1 /)
  call nfseis_grid3d_attput(filenm,      &
       subs,subc,subt,                   &
       ni1,ni2,nj1,nj2,nk1,nk2,ni,nj,nk, &
       nx1,nx2,ny1,ny2,nz1,nz2,nx,ny,nz, &
       ngi1,ngi2,ngj1,ngj2,ngk1,ngk2,    &
       ngx1,ngx2,ngy1,ngy2,ngz1,ngz2,    &
       (/ngi1,ngi2,ngj1,ngj2,ngk1,ngk2/) )
  call nfseis_grid3d_addvar(filenm,'x')
  call nfseis_grid3d_addvar(filenm,'y')
  call nfseis_grid3d_addvar(filenm,'z')
end subroutine coord_skel

subroutine topo_output(filenm)
character (len=*),intent(in) :: filenm
integer :: ncid,ierr,oldMode
integer :: idimid,jdimid,xid,yid,zid

ierr=nf90_create( path=trim(filenm), cmode= nf90_clobber, ncid = ncid )
     call nfseis_except(ierr,'topo_output:'//trim(filenm))
ierr=nf90_set_fill(ncid,nf90_nofill,oldMode)
     call nfseis_except(ierr,'set_fill in topo_output')
! -- define dim
ierr=nf90_def_dim(ncid,'I',NTPI,idimid)
ierr=nf90_def_dim(ncid,'J',NTPJ,jdimid)
! -- define variable
ierr=nf90_def_var(ncid,'x',SEISNC_DATATYPE,(/idimid,jdimid/),xid )
ierr=nf90_def_var(ncid,'y',SEISNC_DATATYPE,(/idimid,jdimid/),yid )
ierr=nf90_def_var(ncid,'z',SEISNC_DATATYPE,(/idimid,jdimid/),zid )
ierr=nf90_enddef(ncid)
ierr=nf90_put_var(ncid,xid,topox)
ierr=nf90_put_var(ncid,yid,topoy)
ierr=nf90_put_var(ncid,zid,topoz)
ierr=nf90_close(ncid)
end subroutine topo_output

subroutine init_grid(fnm_conf)
  character (len=*),intent(in) :: fnm_conf
  character (len=SEIS_STRLEN) :: str
  integer :: fid
  
  fid=1001
  open(fid,file=trim(fnm_conf),status="old")
  
  P%yes=.false.; VA%yes=.false.; VN%yes=.false.
  
  call string_conf(fid,1,'grid_type',2,str)
  select case (trim(str))
  case ('point')
       P%yes=.true.
       call string_conf(fid,1,'grid_format',2,P%filetype)
       call string_conf(fid,1,'grid_filename',2,P%fnm)
       call point_init(P)
  case ('vmap')
       call string_conf(fid,1,'grid_format',2,VA%filetype)
       call string_conf(fid,1,'grid_filename',2,VA%fnm)
       if (trim(VA%filetype)=='nc') then
          VN%yes=.true.; VN%fnm=VA%fnm; VN%filetype=VA%filetype
          call vmapnc_read(VN)
       else
          VA%yes=.true.
          call vmapascii_read(VA)
       end if
  end select
  close(fid)
end subroutine init_grid

! ------------------------- point ---------------------------
subroutine point_init(P)
  type(STRUCT_POINT) :: P
  P%start=(/1,1,1/)
  P%count=(/ni,nj,nk/)
  P%stride=(/1,1,1/)
end subroutine point_init

subroutine point_read(P)
  type(STRUCT_POINT) :: P
  integer,dimension(SEIS_GEO) :: subs,subt,subc
  
  subs=(/ out_i(ngi1),out_j(ngj1),out_k(ngk1) /)
  subc=(/ ni,nj,nk /)
  subt=(/ 1,1,1 /)
  call nfseis_varget(P%fnm,'x',x(ni1:ni2,nj1:nj2,nk1:nk2),subs,subc,subt)
  call nfseis_varget(P%fnm,'y',y(ni1:ni2,nj1:nj2,nk1:nk2),subs,subc,subt)
  call nfseis_varget(P%fnm,'z',z(ni1:ni2,nj1:nj2,nk1:nk2),subs,subc,subt)
end subroutine point_read

! ------------------------- vmapnc ---------------------------
subroutine vmapnc_read(V)
type(STRUCT_VMAPNC) :: V
integer :: imax,jmax,kmax,k

call nfseis_diminfo(V%fnm,'I',imax)
call nfseis_diminfo(V%fnm,'J',jmax)
call nfseis_diminfo(V%fnm,'K',kmax)
call vmapnc_alloc(V,imax,jmax,kmax)

call nfseis_varget(V%fnm,'x',V%x,(/1,1/),(/imax,jmax/),(/1,1/))
call nfseis_varget(V%fnm,'y',V%y,(/1,1/),(/imax,jmax/),(/1,1/))
call nfseis_varget(V%fnm,'interface',V%zgrid,(/1,1,1/),(/imax,jmax,kmax/),(/1,1,1/))
call nfseis_varget(V%fnm,'equal_spacing',V%nspace,(/1/),(/kmax-1/),(/1/))
V%equal=.false.
do k=1,kmax-1
   if (V%nspace(k)==1) V%equal=.true.
end do
call nfseis_varget(V%fnm,'number_of_spacing',V%nspace,(/1/),(/kmax-1/),(/1/))
call vmap_indx_cal(V%nspace,V%indx,kmax)
end subroutine vmapnc_read

subroutine vmapnc_alloc(V,imax,jmax,kmax)
  type(STRUCT_VMAPNC) :: V
  integer,intent(in) :: imax,jmax,kmax
#ifdef GridMPI
  integer :: ierr
#endif
  
  if (kmax<=1) then
     print *, "vmap should contains at least two layers"
#ifdef GridMPI
     call MPI_ABORT(SWMPI_COMM,1,ierr)
#else
     stop 1
#endif
  end if
  allocate(V%x(imax,jmax)); V%x=0.0_SP
  allocate(V%y(imax,jmax)); V%y=0.0_SP
  allocate(V%indx(kmax)); V%indx=0
  allocate(V%nspace(kmax-1)); V%nspace=0
  allocate(V%equal(kmax-1)); V%equal=.false.
  V%ni=imax; V%nj=jmax; V%nk=kmax
  allocate(V%zgrid(nx1:nx2,ny1:ny2,1:kmax)); V%zgrid=0.0_SP
end subroutine vmapnc_alloc

subroutine vmapnc_generate(V)
type(STRUCT_VMAPNC) :: V

real(SP),dimension(dims(3)*nz) :: vecz
real(SP) :: H0,Ha,Hb
integer :: i,j,n,gk,k1,k2

do j=nj1,nj2
#ifdef GridMPI
   if (masternode)  &
#endif
     print *, ' coord_vmap j=',out_j(j), ' of',nj
do i=ni1,ni2

   x(i,j,:)=V%x(i-ni1+out_i(ngi1),j-nj1+out_j(ngj1))
   y(i,j,:)=V%y(i-ni1+out_i(ngi1),j-nj1+out_j(ngj1))

   do n=1,V%nk-1
      k2=V%indx(n); k1=V%indx(n+1)
      if (V%equal(n)) then
         H0=(V%zgrid(i,j,n)-V%zgrid(i,j,n+1))/V%nspace(n)
         do gk=k1,k2
            vecz(gk)=V%zgrid(i,j,n)+(gk-k2)*H0
         end do
      else
         Ha=(V%zgrid(i,j,n-1)-V%zgrid(i,j,n))/V%nspace(n-1)
         Hb=(V%zgrid(i,j,n+1)-V%zgrid(i,j,n+2))/V%nspace(n+1)
         call smooth_z(vecz(k1:k2),V%zgrid(i,j,n)-V%zgrid(i,j,n+1), &
              Ha,Hb,V%nspace(n),V%zgrid(i,j,n+1))
      end if
      vecz(k2)=V%zgrid(i,j,n); vecz(k1)=V%zgrid(i,j,n+1)
   end do
   z(i,j,nk1:nk2)=vecz(ngk1:ngk2)

end do
end do !j
end subroutine vmapnc_generate

! ------------------------- vmapascii ---------------------------
subroutine vmapascii_read(V)
  type(STRUCT_VMAPASCII) :: V
  character (len=SEIS_STRLEN) :: filenm
  integer :: fid,gid
  integer :: i,j,k,imax,jmax,kmax
  
  fid=2001; gid=2002
  open(fid,file=trim(V%fnm),status="old")
  
  !------ xy ----------
  V%ngi=NTPI; V%ngj=NTPJ
  allocate(V%gx(NTPI)); V%gx=0.0_SP
  allocate(V%gy(NTPJ)); V%gy=0.0_SP
  
  call string_conf(fid,1,'coordx_filename',2,filenm)
  open(gid,file=trim(filenm),status='old')
    read(gid,*) i
    if (i<NTPI) then
       print *, 'not enough x grid points'; stop 1
    end if
    read(gid,*) ( V%gx(i),i=1,NTPI )
  close(gid)
  
  call string_conf(fid,1,'coordy_filename',2,filenm)
  open(gid,file=trim(filenm),status='old')
    read(gid,*) j
    if (j<NTPJ) then
       print *, 'not enough y grid points'; stop 1
    end if
    read(gid,*) ( V%gy(j),j=1,NTPJ )
  close(gid)
  
  !-------  vmap nlayer read --------
  call string_conf(fid,1,'vmap_layer_filename',2,filenm)
  !call string_conf(fid,1,'vmap_nlayer',2,kmax)
  open(gid,file=trim(filenm),status='old')
     read(gid,*) imax,jmax,kmax
     call vmapascii_alloc(V,imax,jmax,kmax)
     do j=1,jmax
     do i=1,imax     
         read(gid,*) V%x(i),V%y(j),( V%z(i,j,k), k=1,kmax )
     end do 
     end do
  close(gid)
  
  do k=1,kmax-1
     call string_conf(fid,1,'vmap_spacing_number',k+1,V%nspace(k))
     call string_conf(fid,1,'vmap_spacing_isequal',k+1,V%equal(k))
  end do
  
  call vmap_indx_cal(V%nspace,V%indx,kmax)
  call vmapascii_check(V)
  
  close(fid)
end subroutine vmapascii_read

subroutine vmapascii_alloc(V,imax,jmax,kmax)
  type(STRUCT_VMAPASCII) :: V
  integer,intent(in) :: imax,jmax,kmax
  
  if (kmax<=1) call error_except("vmap should contains at least two layers")

  allocate(V%x(imax)); V%x=0.0_SP
  allocate(V%y(jmax)); V%y=0.0_SP
  allocate(V%z(imax,jmax,kmax)); V%z=0.0_SP
  allocate(V%indx(kmax)); V%indx=0
  allocate(V%nspace(kmax-1)); V%nspace=0
  allocate(V%equal(kmax-1)); V%equal=.false.
  V%ni=imax; V%nj=jmax; V%nk=kmax
  allocate(V%zgrid(nx1:nx2,ny1:ny2,1:kmax)); V%zgrid=0.0_SP
end subroutine vmapascii_alloc

subroutine vmapascii_check(V)
  type(STRUCT_VMAPASCII),intent(in) :: V
  integer :: k
  
  ! layer depth
  do k=1,V%nk-1
     if (any(V%z(:,:,k)<V%z(:,:,k+1))) then
        print *, 'layer',k,' should be beyond layer',k+1
        print *, minloc(V%z(:,:,k)-V%z(:,:,k+1))
        call error_except('vmapascii_check failed')
     end if
  end do
  ! if equal for first and last layer
  if ( (.not. V%equal(1)) .or. (.not. V%equal(V%nk-1))) then
     call error_except('first and last-1 layer should have equal grid')
  end if
  ! if two gradient spacing layer adjacent
  do k=1,V%nk-2
     if (V%equal(k) .or. V%equal(k+1)) cycle
     call error_except("unequal grid can't be adjacent")
  end do
end subroutine vmapascii_check

subroutine vmapascii_generate(V)
type(STRUCT_VMAPASCII) :: V

real(SP),dimension(NTPZ) :: vecz
real(SP) :: H0,Ha,Hb
integer :: i,j,n,gk,k1,k2

! x y first
do j=nj1,nj2
do i=ni1,ni2
   x(i,j,:)=V%gx(i-ni1+npi1)
   y(i,j,:)=V%gy(j-nj1+npj1)
end do
end do

call vmapascii_zgrid_interp(V)

do j=nj1,nj2
#ifdef GridMPI
   if (masternode)  &
#endif
     print *, ' coord_vmap j=',j-nj1+1, ' of',nj
do i=ni1,ni2

   do n=1,V%nk-1
      k2=V%indx(n); k1=V%indx(n+1)
      if (V%equal(n)) then
         H0=(V%zgrid(i,j,n)-V%zgrid(i,j,n+1))/V%nspace(n)
         do gk=k1,k2
            vecz(gk)=V%zgrid(i,j,n)+(gk-k2)*H0
         end do
      else
         Ha=(V%zgrid(i,j,n-1)-V%zgrid(i,j,n))/V%nspace(n-1)
         Hb=(V%zgrid(i,j,n+1)-V%zgrid(i,j,n+2))/V%nspace(n+1)
         call smooth_z(vecz(k1:k2),V%zgrid(i,j,n)-V%zgrid(i,j,n+1), &
              Ha,Hb,V%nspace(n),V%zgrid(i,j,n+1))
      end if
      vecz(k2)=V%zgrid(i,j,n); vecz(k1)=V%zgrid(i,j,n+1)
   end do
   z(i,j,nk1:nk2)=vecz(ngk1:ngk2)

end do
end do !j
end subroutine vmapascii_generate

subroutine vmapascii_zgrid_interp(V)
  type(STRUCT_VMAPASCII) :: V
  real(SP) :: x1,y1
  integer :: i1,i2,j1,j2
  integer :: i,j,k
  ! interpolate zgrid
  do j=nj1,nj2
  do i=ni1,ni2
     !x1=min(max(x(i,j,k),V%x(1)),V%x(imax))
     !y1=min(max(y(i,j,k),V%y(1)),V%y(jmax))
     ! not safe, should be considered further
     !p=minloc(V%x,V%x-x1+SEIS_EQUAL>=0.0);i2=max(p(1),2);i1=i2-1
     !p=minloc(V%y,V%y-y1+SEIS_EQUAL>=0.0);j2=max(p(1),2);j1=j2-1
     call indx_locate_1d(x(i,j,nk2),V%x,i1,i2,x1)
     call indx_locate_1d(y(i,j,nk2),V%y,j1,j2,y1)
  do k=1,V%nk
     V%zgrid(i,j,k)=interp_2d( &
             V%x(i1:i2),V%y(j1:j2),V%z(i1:i2,j1:j2,k),  &
             2,2,x1,y1)
  end do
  end do
  end do
end subroutine vmapascii_zgrid_interp

! ------------------------- vmap ---------------------------
subroutine vmap_indx_cal(nspace,indx,kmax)
integer,dimension(:) :: nspace,indx
integer,intent(in) :: kmax
integer :: n
indx(kmax)=nk1
do n=kmax-1,1,-1
   indx(n)=indx(n+1)+nspace(n)
end do
end subroutine vmap_indx_cal

subroutine smooth_z(z,L,Ha,Hb,N,z0)
real(SP),dimension(N+1),intent(out) :: z
real(SP),intent(in) :: L,Ha,Hb,z0
integer,intent(in) :: N

real(SP) :: step(0:N+1)
integer k,Na,Nb,N0
real(SP) fct,La1,La2,Lb1,Lb2,Ha1,Ha2,Hb1,Hb2,L0,H0,Ha0,Hb0

H0=L/N;

step(0)=Hb; step(N+1)=Ha

if (     (H0<=Hb .and. H0>=Ha) &
    .or. (H0>=Hb .and. H0<=Ha)) then
Nb=1; Na=N; N0=N
do
   L0=0.0;fct=(Ha/Hb)**(1.0/(N0+1))-1.0
   step(1:Nb-1)=Hb; step(Na+1:N+1)=Ha
   do k=Nb,Na
      step(k)=step(k-1)*(1+fct);
      L0=L0+step(k)
   end do
   Ha1=Ha*min(1.0,1.0-fct); Ha2=Ha*max(1.0,1.0-fct)
   Hb1=Hb*min(1.0,1.0+fct); Hb2=Hb*max(1.0,1.0+fct)
   La1=(N-Na)*Ha1; La2=(N-Na)*Ha2
   Lb1=(Nb-1)*Hb1; Lb2=(Nb-1)*Hb2
   if (La1+Lb1<=L-L0 .and. L-L0<=Lb2+La2)  then
      call set_twoside_space(L-L0,N-Na,Nb-1, &
           Ha1,Ha2,Hb1,Hb2,Ha0,Hb0)
      step(Na+1:N)=Ha0
      step(1:Nb-1)=Hb0
      exit
   elseif (L-L0<La1+Lb1) then
      if (Ha<Hb) then
         Na=Na-1; N0=N0-1
      else
         Nb=Nb+1; N0=N0-1
      end if
   else
      if (Ha<Hb) then
         Nb=Nb+1; N0=N0-1
      else
         Na=Na-1; N0=N0-1
      end if
   end if
end do

else

Na=N/4; Nb=N/4; N0=N-Na-Nb;
La1=(Na+1)*Na/2.0
Lb1=(Nb+1)*Nb/2.0
L0=L-Na*Ha-Nb*Hb-N0*Ha-Lb1*(Ha-Hb)/Nb
La2=La1+Na*Lb1/Nb+Na*N0
Ha0=L0/La2
Hb0=(Na*Ha0+Ha-Hb)/Nb
do k=1,Nb
   step(k)=Hb+k*Hb0
end do
do k=Nb+1,Nb+N0
   step(k)=step(k-1)
end do
do k=Nb+N0+1,N
   step(k)=Ha+(N-k+1)*Ha0
end do

end if

!assemble z
z(1)=0;
do k=1,N
    z(k+1)=z(k)+step(k);
end do
z=z+z0
end subroutine smooth_z

subroutine set_twoside_space(L,Na,Nb, &
   Ha1,Ha2,Hb1,Hb2,Ha0,Hb0)
real(SP),intent(in) :: L,Ha1,Ha2,Hb1,Hb2
real(SP),intent(out) :: Ha0,Hb0
integer,intent(in) :: Na,Nb
real(SP) L0,La,Lb
L0=L-Na*Ha1-Nb*Hb1
La=Na*(Ha2-Ha1)
Lb=Nb*(Hb2-Hb1)
if (abs(L0)<SEIS_EQUAL) then
   Ha0=Ha1; Hb0=Hb1
elseif (abs(La)<SEIS_EQUAL) then
   Ha0=Ha1; Hb0=Hb1+L0/Nb
elseif (abs(Lb)<SEIS_EQUAL) then
   Hb0=Hb1; Ha0=Ha1+L0/Na
else
   Ha0=Ha1+(L0*La/(La+Lb))/Na
   Hb0=Hb1+(L0*Lb/(La+Lb))/Nb
end if
end subroutine set_twoside_space

subroutine indx_locate_1d(x0,x,i1,i2,x1)
real(SP),intent(in) :: x0
real(SP),dimension(:),intent(in) :: x
integer,intent(out) :: i1,i2
real(SP),intent(out) :: x1
integer :: i0
!logical,intent(in) :: backward
  !integer :: indx(1)
  !indx=minloc(x,x>=x0)
  !i2=max(indx(1),2)
  !i1=i2-1

i1=1; i2=size(x); x1=x0
if (x0<=x(1)) then
   x1=x(1); i1=1; i2=i1+1
elseif (x0>=x(i2)) then
   x1=x(i2); i1=i2-1
else
  do while (i2-i1>1)
     i0=(i2-i1)/2+i1
     if (x(i0)==x0) then
        i1=i0;i2=i0+1; exit
     elseif (x(i0)>x0) then
        i2=i0;
     else
        i1=i0
     end if
  end do
end if
end subroutine indx_locate_1d

!*************************************************************************
!*                             coordinate util                           *
!*************************************************************************

subroutine coord_extend
  call extend_crew(x)
  call extend_crew(y)
  call extend_crew(z)
end subroutine coord_extend

subroutine extend_crew(w)
   real(SP),dimension(nx1:nx2,ny1:ny2,nz1:nz2),intent(inout) :: w
   integer i,j,k,n
   ! x1, x2
   do k=nz1,nz2
   do j=ny1,ny2
      do n=1,LenFD
         w(ni1-n,j,k)=2.0*w(ni1,j,k)-w(ni1+n,j,k)
         w(ni2+n,j,k)=2.0*w(ni2,j,k)-w(ni2-n,j,k)
      end do
   end do
   end do
   ! y1, y2
   do k=nz1,nz2
   do i=nx1,nx2
      do n=1,LenFD
         w(i,nj1-n,k)=2.0*w(i,nj1,k)-w(i,nj1+n,k)
         w(i,nj2+n,k)=2.0*w(i,nj2,k)-w(i,nj2-n,k)
      end do
   end do
   end do
   ! z1, z2
   do j=ny1,ny2
   do i=nx1,nx2
      do n=1,LenFD
         w(i,j,nk1-n)=2.0*w(i,j,nk1)-w(i,j,nk1+n)
         w(i,j,nk2+n)=2.0*w(i,j,nk2)-w(i,j,nk2-n)
      end do
   end do
   end do
end subroutine extend_crew
subroutine extend_symm(w)
   real(SP),dimension(nx1:nx2,ny1:ny2,nz1:nz2),intent(inout) :: w
   integer i,j,k,n
   ! x1, x2
   do k=nk1,nk2
   do j=nj1,nj2
      do n=1,LenFD
         w(ni1-n,j,k)=w(ni1+n,j,k)
         w(ni2+n,j,k)=w(ni2-n,j,k)
      end do
   end do
   end do
   ! y1, y2
   do k=nk1,nk2
   do i=ni1,ni2
      do n=1,LenFD
         w(i,nj1-n,k)=w(i,nj1+n,k)
         w(i,nj2+n,k)=w(i,nj2-n,k)
      end do
   end do
   end do
   ! z1, z2
   do j=nj1,nj2
   do i=ni1,ni2
      do n=1,LenFD
         w(i,j,nk1-n)=w(i,j,nk1+n)
         w(i,j,nk2+n)=w(i,j,nk2-n)
      end do
   end do
   end do
end subroutine extend_symm

#ifdef GridMPI
subroutine coord_exchange
integer :: ierr
integer,dimension(MPI_STATUS_SIZE) :: istatus
call MPI_SENDRECV(x(ni1  ,ny1,nz1),1,DTypeXL,neigid(1,1),111,        &
                  x(ni2+1,ny1,nz1),1,DTypeXL,neigid(1,2),111,        &
                  SWMPI_COMM,istatus,ierr)
call MPI_SENDRECV(x(ni2-LenFDL+1,ny1,nz1),1,DTypeXL,neigid(1,2),112, &
                  x(ni1-LenFDL  ,ny1,nz1),1,DTypeXL,neigid(1,1),112, &
                  SWMPI_COMM,istatus,ierr)
call MPI_SENDRECV(x(nx1,nj1  ,nz1),1,DTypeYL,neigid(2,1),121,        &
                  x(nx1,nj2+1,nz1),1,DTypeYL,neigid(2,2),121,        &
                  SWMPI_COMM,istatus,ierr)
call MPI_SENDRECV(x(nx1,nj2-LenFDL+1,nz1),1,DTypeYL,neigid(2,2),122, &
                  x(nx1,nj1-LenFDL  ,nz1),1,DTypeYL,neigid(2,1),122, &
                  SWMPI_COMM,istatus,ierr)
call MPI_SENDRECV(x(nx1,ny1,nk1  ),1,DTypeZL,neigid(3,1),131,        &
                  x(nx1,ny1,nk2+1),1,DTypeZL,neigid(3,2),131,        &
                  SWMPI_COMM,istatus,ierr)
call MPI_SENDRECV(x(nx1,ny1,nk2-LenFDL+1),1,DTypeZL,neigid(3,2),132, &
                  x(nx1,ny1,nk1-LenFDL  ),1,DTypeZL,neigid(3,1),132, &
                  SWMPI_COMM,istatus,ierr)
call MPI_SENDRECV(y(ni1  ,ny1,nz1),1,DTypeXL,neigid(1,1),211,        &
                  y(ni2+1,ny1,nz1),1,DTypeXL,neigid(1,2),211,        &
                  SWMPI_COMM,istatus,ierr)
call MPI_SENDRECV(y(ni2-LenFDL+1,ny1,nz1),1,DTypeXL,neigid(1,2),212, &
                  y(ni1-LenFDL  ,ny1,nz1),1,DTypeXL,neigid(1,1),212, &
                  SWMPI_COMM,istatus,ierr)
call MPI_SENDRECV(y(nx1,nj1  ,nz1),1,DTypeYL,neigid(2,1),221,        &
                  y(nx1,nj2+1,nz1),1,DTypeYL,neigid(2,2),221,        &
                  SWMPI_COMM,istatus,ierr)
call MPI_SENDRECV(y(nx1,nj2-LenFDL+1,nz1),1,DTypeYL,neigid(2,2),222, &
                  y(nx1,nj1-LenFDL  ,nz1),1,DTypeYL,neigid(2,1),222, &
                  SWMPI_COMM,istatus,ierr)
call MPI_SENDRECV(y(nx1,ny1,nk1  ),1,DTypeZL,neigid(3,1),231,        &
                  y(nx1,ny1,nk2+1),1,DTypeZL,neigid(3,2),231,        &
                  SWMPI_COMM,istatus,ierr)
call MPI_SENDRECV(y(nx1,ny1,nk2-LenFDL+1),1,DTypeZL,neigid(3,2),232, &
                  y(nx1,ny1,nk1-LenFDL  ),1,DTypeZL,neigid(3,1),232, &
                  SWMPI_COMM,istatus,ierr)
call MPI_SENDRECV(z(ni1  ,ny1,nz1),1,DTypeXL,neigid(1,1),311,        &
                  z(ni2+1,ny1,nz1),1,DTypeXL,neigid(1,2),311,        &
                  SWMPI_COMM,istatus,ierr)
call MPI_SENDRECV(z(ni2-LenFDL+1,ny1,nz1),1,DTypeXL,neigid(1,2),312, &
                  z(ni1-LenFDL  ,ny1,nz1),1,DTypeXL,neigid(1,1),312, &
                  SWMPI_COMM,istatus,ierr)
call MPI_SENDRECV(z(nx1,nj1  ,nz1),1,DTypeYL,neigid(2,1),321,        &
                  z(nx1,nj2+1,nz1),1,DTypeYL,neigid(2,2),321,        &
                  SWMPI_COMM,istatus,ierr)
call MPI_SENDRECV(z(nx1,nj2-LenFDL+1,nz1),1,DTypeYL,neigid(2,2),322, &
                  z(nx1,nj1-LenFDL  ,nz1),1,DTypeYL,neigid(2,1),322, &
                  SWMPI_COMM,istatus,ierr)
call MPI_SENDRECV(z(nx1,ny1,nk1  ),1,DTypeZL,neigid(3,1),331,        &
                  z(nx1,ny1,nk2+1),1,DTypeZL,neigid(3,2),331,        &
                  SWMPI_COMM,istatus,ierr)
call MPI_SENDRECV(z(nx1,ny1,nk2-LenFDL+1),1,DTypeZL,neigid(3,2),332, &
                  z(nx1,ny1,nk1-LenFDL  ),1,DTypeZL,neigid(3,1),332, &
                  SWMPI_COMM,istatus,ierr)
end subroutine coord_exchange
#else
subroutine coord_exchange
character (len=SEIS_STRLEN) :: filenm
integer,dimension(SEIS_GEO) :: subt
integer,dimension(SEIS_GEO) ::         &
     subs_x1,subc_x1, subs_x2,subc_x2, &
     subs_y1,subc_y1, subs_y2,subc_y2, &
     subs_z1,subc_z1, subs_z2,subc_z2
integer,dimension(LenFD) ::            &
     indx_x1,indx_x2,indx_y1,indx_y2,indx_z1,indx_z2
integer :: n_i,n_j,n_k
integer :: i,j,k

subt=(/ 1,1,1 /)
subs_x1=(/ ni2+1,ny1  ,nz1  /); subc_x1=(/ LenFD , ny    , nz    /)
subs_x2=(/ nx1  ,ny1  ,nz1  /); subc_x2=(/ LenFD , ny    , nz    /)
subs_y1=(/ nx1  ,nj2+1,nz1  /); subc_y1=(/ nx    , LenFD , nz    /)
subs_y2=(/ nx1  ,ny1  ,nz1  /); subc_y2=(/ nx    , LenFD , nz    /)
subs_z1=(/ nx1  ,ny1  ,nk2+1/); subc_z1=(/ nx    , ny    , LenFD /)
subs_z2=(/ nx1  ,ny1  ,nz1  /); subc_z2=(/ nx    , ny    , LenFD /)
indx_x1=(/ (i,i=ni1,ni1+LenFD-1) /)
indx_x2=(/ (i,i=ni2-LenFD+1,ni2) /)
indx_y1=(/ (j,j=nj1,nj1+LenFD-1) /)
indx_y2=(/ (j,j=nj2-LenFD+1,nj2) /)
indx_z1=(/ (k,k=nk1,nk1+LenFD-1) /)
indx_z2=(/ (k,k=nk2-LenFD+1,nk2) /)

do n_i=0,dims(1)-1
do n_j=0,dims(2)-1
do n_k=0,dims(3)-1
   write(*,"(i10,2(i2),a,3(i2))") n_i,n_j,n_k, ' of ',dims
   call swmpi_change_fnm(n_i,n_j,n_k)
   call swmpi_set_gindx(n_i,n_j,n_k)
   call grid_coord_import(n_i,n_j,n_k)

   ! to x1
   if (n_i>0) then
      call swmpi_change_fnm(n_i-1,n_j,n_k)
      filenm=grid_coordfnm_get(n_i-1,n_j,n_k)
      call nfseis_varput(filenm,'x',x(indx_x1,:,:),subs_x1,subc_x1,subt)
      call nfseis_varput(filenm,'y',y(indx_x1,:,:),subs_x1,subc_x1,subt)
      call nfseis_varput(filenm,'z',z(indx_x1,:,:),subs_x1,subc_x1,subt)
   end if
   ! to x2
   if (n_i<dims(1)-1) then
      call swmpi_change_fnm(n_i+1,n_j,n_k)
      filenm=grid_coordfnm_get(n_i+1,n_j,n_k)
      call nfseis_varput(filenm,'x',x(indx_x2,:,:),subs_x2,subc_x2,subt)
      call nfseis_varput(filenm,'y',y(indx_x2,:,:),subs_x2,subc_x2,subt)
      call nfseis_varput(filenm,'z',z(indx_x2,:,:),subs_x2,subc_x2,subt)
   end if
   ! to y1
   if (n_j>0) then
      call swmpi_change_fnm(n_i,n_j-1,n_k)
      filenm=grid_coordfnm_get(n_i,n_j-1,n_k)
      call nfseis_varput(filenm,'x',x(:,indx_y1,:),subs_y1,subc_y1,subt)
      call nfseis_varput(filenm,'y',y(:,indx_y1,:),subs_y1,subc_y1,subt)
      call nfseis_varput(filenm,'z',z(:,indx_y1,:),subs_y1,subc_y1,subt)
   end if
   ! to y2
   if (n_j<dims(2)-1) then
      call swmpi_change_fnm(n_i,n_j+1,n_k)
      filenm=grid_coordfnm_get(n_i,n_j+1,n_k)
      call nfseis_varput(filenm,'x',x(:,indx_y2,:),subs_y2,subc_y2,subt)
      call nfseis_varput(filenm,'y',y(:,indx_y2,:),subs_y2,subc_y2,subt)
      call nfseis_varput(filenm,'z',z(:,indx_y2,:),subs_y2,subc_y2,subt)
   end if
   ! to k1
   if (n_k>0) then
      call swmpi_change_fnm(n_i,n_j,n_k-1)
      filenm=grid_coordfnm_get(n_i,n_j,n_k-1)
      call nfseis_varput(filenm,'x',x(:,:,indx_z1),subs_z1,subc_z1,subt)
      call nfseis_varput(filenm,'y',y(:,:,indx_z1),subs_z1,subc_z1,subt)
      call nfseis_varput(filenm,'z',z(:,:,indx_z1),subs_z1,subc_z1,subt)
   end if
   ! to k2
   if (n_k<dims(3)-1) then
      call swmpi_change_fnm(n_i,n_j,n_k+1)
      filenm=grid_coordfnm_get(n_i,n_j,n_k+1)
      call nfseis_varput(filenm,'x',x(:,:,indx_z2),subs_z2,subc_z2,subt)
      call nfseis_varput(filenm,'y',y(:,:,indx_z2),subs_z2,subc_z2,subt)
      call nfseis_varput(filenm,'z',z(:,:,indx_z2),subs_z2,subc_z2,subt)
   end if
end do
end do
end do
end subroutine coord_exchange
#endif

subroutine error_except(msg)
  character (len=*),intent(in) :: msg
#ifdef GridMPI
  integer :: ierr
#endif
  print *, trim(msg)
#ifdef GridMPI
  call MPI_ABORT(SWMPI_COMM,1,ierr)
#else
  stop 1
#endif
end subroutine error_except

end program seis3d_grid

! vim:ft=fortran:ts=4:sw=4:nu:et:ai:

